package name.heavycarbon.h2_exercises.transactions.agent;

import name.heavycarbon.h2_exercises.transactions.db.Db;
import name.heavycarbon.h2_exercises.transactions.session.Isol;
import name.heavycarbon.h2_exercises.transactions.session.SessionInfoExt;
import name.heavycarbon.h2_exercises.transactions.session.SessionManip;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;

import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Supplier;

// NB This is not an autowired Component or a superclass of one
// So that we can recreate it easily in tests.
@Slf4j
public abstract class AgentRunnable implements Runnable {

    protected final @NotNull Db db;
    public final @NotNull AppState appState;
    public final @NotNull AgentId agentId;
    public final @NotNull Isol isol;

    private final AtomicBoolean stop = new AtomicBoolean(false);

    public void setStop() {
        stop.set(true);
    }

    // A callback to a method that can query all the Runnables regarding
    // whether they have "terminated nicely" or not. This can done only in
    // code that "belongs to some manager". May be left unset.

    @Setter
    private Supplier<Boolean> anyThreadTerminatedBadly;

    // If a thread "terminates nicely", it sets this flag before exiting
    // "atomic" to make sure reading & writing is consistent. Could also be
    // a "volatile boolean"

    @Getter
    private final AtomicBoolean terminatedNicely = new AtomicBoolean(false);

    // Instead of marking db and appState as "@Autowired",
    // make them final and autowire through the constructor.

    public AgentRunnable(@NotNull Db db, @NotNull AppState appState, @NotNull AgentId agentId, @NotNull Isol isol) {
        this.db = db;
        this.appState = appState;
        this.agentId = agentId;
        this.isol = isol;
    }

    public boolean isAnyThreadTerminatedBadly() {
        return (anyThreadTerminatedBadly != null) && anyThreadTerminatedBadly.get();
    }

    public boolean isTerminatedNicely() {
        return terminatedNicely.get();
    }

    public void setTerminatedNicely() {
        terminatedNicely.set(true);
    }

    public boolean isContinue() {
        return !stop.get() && !anyThreadTerminatedBadly.get();
    }

    // ---
    // This is only called if the caller holds the monitor to appState
    // ---

    public void moveToState(int newState) {
        // no need to synchronize again, but let's make clear what we want
        synchronized (appState) {
            appState.set(newState);
            appState.notify(); // must hold monitor for this
        }
    }

    public void incState() {
        // no need to synchronize again, but let's make clear what we want
        synchronized (appState) {
            appState.incrementAndGet();
            appState.notify(); // must hold monitor for this
        }
    }

    // ---
    // This is only called if the caller holds the monitor to appState
    // Waiting forever should work but will lead to lockup if the
    // other thread crashes! Wait a few ms instead.
    // ---

    private final static long wait_ms = 100;

    public void waitOnAppState() throws InterruptedException {
        // no need to synchronize again, but let's make clear what we want
        synchronized (appState) {
            if (isContinue()) {
                appState.wait(wait_ms);
            }
        }
    }

    public static String printAllSessions(@NotNull SessionManip sm) {
        List<SessionInfoExt> list = sm.getAllSessionsInfo();
        StringBuilder buf = new StringBuilder("Sessions");
        for (SessionInfoExt iext : list) {
            buf.append("\n");
            buf.append("   ");
            buf.append(iext.sessionId());
            buf.append(", ");
            buf.append(iext.isol());
            if (iext.isMySession()) {
                buf.append(", mine");
            }
        }
        return buf.toString();
    }

    public String finalMessage(boolean interrupted) {
        return agentId + " terminating. stop: " + stop + ", interrupted: " + interrupted + ", bad threads: " + isAnyThreadTerminatedBadly();
    }

    // Be able to also catch org.opentest4j.AssertionFailedError generated by failed assertions.
    public static void throwableMessage(@NotNull Logger log, @NotNull AgentId agentId, @NotNull Throwable throwable) {
        log.error("{} terminating due to {} with message '{}'", agentId, throwable.getClass().getName(), throwable.getMessage());
    }
}
